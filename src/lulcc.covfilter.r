#' Filter covariates for land use land cover change (LULCC) models
#'
#' **Documentation generated by Claude 3.7 and checked by mmyrte.** This function
#' filters a set of covariates for land use land cover change (LULCC) models based on
#' various statistical methods and correlation thresholds.
#'
#' @param cov_data A data frame containing the candidate covariates to be filtered.
#' @param trans_result A vector representing the transition results (response variable).
#'        Can be binary (0/1) or multi-class.
#' @param method A character string specifying the variable selection method. Options
#'        include: "IQR" (Interquartile Range), "IQR.M" (IQR divided by median), "COR.P"
#'        (Pearson correlation), "COR.S" (Spearman correlation), "WIL" (Wilcoxon test
#'        p-values), "GLM" (Generalized Linear Model p-values), "MAD.M" (Median Absolute
#'        Deviation divided by median).
#' @param weights Optional vector of weights to be used in the GLM method.
#' @param corcut Numeric threshold (0-1) for correlation filtering. Covariates with correlation
#'        coefficients above this threshold will be filtered out. Default is 0 (no filtering).
#'
#' @return A filtered data frame containing only the selected covariates after ranking
#'         by the specified method and filtering based on correlation threshold.
#'
#' @details
#' The function first ranks covariates using the specified method, then iteratively
#' removes highly correlated variables based on the correlation cutoff threshold.
#' For binary response variables (trans_result has â‰¤2 unique values), it uses various
#' statistical measures depending on the specified method.
#' For multi-class response variables (trans_result has >2 unique values), it uses
#' multinomial models and p-values for variable selection.
#'
#' If there's only one covariate in the input data, the function returns it unchanged.
#' @author Antoine Adde (main) edited by Ben Black

lulcc_covfilter <- function(
  cov_data,
  trans_result,
  method,
  weights,
  corcut = 0
) {
  # If only one covariate in the candidate set, don't do anything
  if (ncol(cov_data) == 1) {
    cov_data.filter <- cov_data
    return(cov_data.filter)
  }

  # Bind covariates and trans_result data
  covdata <- cbind(cov_data, trans_result = factor(trans_result))

  # Rank candidate covariates using selected method
  if (as.numeric(length(unique(trans_result))) <= 2) {
    # approach for binary datasets
    if (method == "IQR") {
      covranked <- data.frame(
        iqr = sort(
          sapply(
            subset(
              covdata[covdata$trans_result == 1, ],
              select = -c(trans_result),
              IQR
            )
          )
        )
      )
    }

    if (method == "IQR.M") {
      covranked <- data.frame(
        iqr = sort(
          abs(
            sapply(
              subset(
                covdata[covdata$trans_result == 1, ],
                select = -c(trans_result)
              ),
              IQR
            ) /
              sapply(
                subset(
                  covdata[covdata$trans_result == 1, ],
                  select = -c(trans_result)
                ),
                median
              )
          )
        )
      )
    }

    if (method == "COR.P") {
      covranked <- data.frame(
        cor = abs(
          t(
            cor(
              trans_result,
              as.matrix(
                subset(covdata, select = -c(trans_result))
              ),
              method = "pearson",
              use = "complete.obs"
            )
          )
        )
      )
      covranked <- covranked[order(-covranked$cor), , drop = FALSE]
    }

    if (method == "COR.S") {
      covranked <- data.frame(
        cor = abs(
          t(
            cor(
              trans_result,
              as.matrix(subset(covdata, select = -c(trans_result))),
              method = "spearman",
              use = "complete.obs"
            )
          )
        )
      )
      covranked <- covranked[order(-covranked$cor), , drop = FALSE]
    }

    if (method == "WIL") {
      res <- sort(
        apply(
          subset(covdata, select = -c(trans_result)),
          2,
          function(x) {
            wilcox.test(x ~ covdata$trans_result)$p.value
          }
        )
      )
      covranked <- data.frame(wil = res, row.names = names(res))
    }

    if (method == "GLM") {
      res <- sort(
        apply(
          cov_data,
          2,
          function(x) {
            # TODO this loop is very hot and needs to be optimized if kept
            min(
              summary(
                glm(
                  trans_result ~ poly(x, degree = 2, simple = TRUE),
                  family = "binomial",
                  weights = weights
                )
              )$coefficients[2:3, 4]
            ) # This is subsetting too the p value of the intercept and the covariate
          }
        )
      )
      covranked <- data.frame(pval = res, row.names = names(res))
    }

    if (method == "MAD.M") {
      covranked <- data.frame(
        iqr = sort(
          abs(
            sapply(
              subset(
                covdata[covdata$trans_result == 1, ],
                select = -c(trans_result)
              ),
              mad
            ) /
              sapply(
                subset(
                  covdata[covdata$trans_result == 1, ],
                  select = -c(trans_result)
                ),
                median
              )
          )
        )
      )
    }
  }

  if (length(unique(trans_result)) > 2) {
    # This is for Multiclass datasets

    res <- sort(
      apply(
        subset(
          covdata,
          select = -c(trans_result)
        ),
        2,
        function(x) {
          # loop over covariates

          # set baseline category of dependent variable for multinomial model
          baseline_trans_ID <- tail(
            unique(covdata$trans_result),
            1
          ) # identify last unique transition ID
          trans_result_RL <- relevel(
            covdata$trans_result,
            ref = baseline_trans_ID
          ) # relevel the trans-result vector

          # run multinomial model
          mn_model <- multinom(trans_result_RL ~ poly(x, 2))

          # calculate z value
          z <- summary(mn_model)$coefficients /
            summary(mn_model)$standard.errors

          # calculate p value
          # p values for cov and it's polynomial across all values of dependent variables
          p <- ((1 - pnorm(abs(z), 0, 1)) * 2)
          # take an average p value across the values of dependent variable for the
          # covariate and it's polynomial seperately and then keep only the minimum
          # value.
          p_min <- min(c(mean(p[, 2]), mean(p[, 3])))

          return(p_min)
        }
      )
    )
    covranked <- data.frame(pval = res, row.names = names(res))
  }

  # Reorder covdata accordingly and compute initial correlation matrix
  cov_names <- row.names(covranked)
  covdata.ranked <- data.frame(covdata[, cov_names])

  # This is calculating the Pearsons correlation coefficient (the default for the
  # function) of the ranked covariates
  cor.mat <- abs(cor(covdata.ranked, use = "pairwise.complete.obs"))

  # Thin candidate covariate set until no pairwise correlation > corcut
  # sanctuaire receives the thinned covariate list and iteratively updated until the
  # corellation cut off is reached.
  sanctuaire <- NULL

  if (all(cor.mat[cor.mat != 1] < corcut)) {
    sanctuaire <- c(sanctuaire, row.names(cor.mat))
  } else {
    while (length(cor.mat) > 1) {
      tmp_cm <- data.frame(cor.mat[, 1])
      ix <- which(tmp_cm[, 1] <= corcut)
      var.name <- row.names(cor.mat)[1]
      sanctuaire <- c(sanctuaire, var.name)
      cor.mat <- cor.mat[ix, ix]
      if (all(cor.mat[cor.mat != 1] < corcut)) {
        sanctuaire <- c(sanctuaire, row.names(cor.mat))
        break
      }
    }
  }

  # Return dataframe of selected covariates
  cov_data.filter <- as.data.frame(covdata[, sanctuaire])
  if (length(sanctuaire) == 1) {
    colnames(cov_data.filter) <- sanctuaire
  }
  return(cov_data.filter)
}
